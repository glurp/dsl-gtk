{"name":"Ruiby","tagline":"DSL for make a simple ruby GUI application","body":"\r\nResources\r\n==========\r\n\r\n\r\nCode: http://github.com/glurp/Ruiby\r\n\r\nDoc: [Reference+Exemples.](https://rawgithub.com/glurp/Ruiby/master/doc.html)   \r\n\r\nGem : https://rubygems.org/gems/Ruiby\r\n\r\n\r\n\r\nInstallation\r\n============\r\n1) system\r\n\r\nInstall Ruby 3.x\r\n\r\n\r\n2) install Ruiby\r\n(Ruiby install ruby-gtk3 which install gtk3 libs)\r\n\r\n```\r\n> gem install Ruiby\r\n\r\n> ruiby_demo             # check good installation with gtk3 (default)\r\n> ruiby_sketchi          # write and test ruiby code\r\n```\r\n3) if you need video/gstreamer, install gst/clutter :\r\n```\r\n  > gem install gstreamer \r\n  > gem install clutter-gtk\r\n  > gem install clutter-gstreamer\r\n```\r\n\r\nHere a working gem config on windows (15-September-2014, ruby 2.0.0p0) :\r\n```\r\n pkg-config  1.1.4\r\n       cairo 1.12.8\r\n      glib2  2.2.0\r\n gobject-introspection  2.2.0\r\n       gio2  2.2.0\r\n        atk  2.2.0\r\n      pango  2.2.0\r\n gdk_pixbuf2  2.2.0\r\n       gdk3  2.2.0\r\n       gtk3  2.2.0\r\n  gstreamer  2.2.0\r\n cairo-gobject  2.2.0\r\n    clutter  2.2.0\r\nclutter-gtk  2.2.0\r\n clutter-gstreamer  2.2.0\r\n```\r\n  \r\n\r\nUsage\r\n======\r\nDSL is usable via inherit, include, Ruiby.app bloc, or one-liner command.\r\n\r\nBy inherit:\r\n\r\n```ruby\r\nclass Application < Ruiby_gtk\r\n    def initialize(t,w,h)\r\n        super(t,w,h)\r\n    end\t\r\n\tdef component()\r\n\t  stack do\r\n\t\t...\r\n\t  end\r\n\tend\r\n\t.....your code....\r\nend\r\nRuiby.start { Win.new(\"application title\",350,10) }\r\n\r\n```\r\n\r\nBy include, calling ruiby_component() :\r\n\r\n```ruby\r\nclass Win < Gtk::Window\r\n\tinclude Ruiby\r\n    def initialize(t,w,h)\r\n        super()\r\n\t\tadd(@vb=VBox.new(false, 2)) \r\n\t\t....\r\n    end\t\r\n\tdef add_a_ruiby_button() \r\n\t\truiby_component do\r\n\t\t\tappend_to(@vb) do \r\n\t\t\t\tbutton(\"Hello Word #{@vb.children.size}\") {\r\n\t\t\t\t\tadd_a_ruiby_button() \r\n\t\t\t\t}\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\nRuiby.start { Win.new(\"application title\",350,10) }\r\n```\r\n\r\nAutonomous DSL, for  little application :\r\n\r\n```ruby \r\nrequire  'Ruiby'\r\nRuiby.app do\r\n\tstack do\r\n\t\t. . . \r\n\tend\r\nend\r\n```\r\nAnd, for very little application ('~' are replaced by guillemet):\r\n\r\n```ruby \r\n\r\n> ruiby   button(~Continue ? ~) \"{  exit!(0) }\"\r\n> ruiby   fields([%w{a b},%w{b c},%w{c d}]) { \"|a,b,c|\" p [a,b,c] if a; exit!(a ?0:1) }\r\n> ruiby -width 100  -height 300 -title \"Please, select a file\" \\\r\n             l=list(~Files :~);l.set_data Dir.glob(~*~) ;  \\\r\n             buttoni(~Selected~) { puts l.selection ; exit!(0) } ;\\\r\n\t\t\t buttoni(~Annul~) { exit!(1) }\r\n\r\n```\r\n\r\nRequire\r\n=======\r\nSimple usage with gtk3 :\r\n\r\n```ruby \r\nrequire 'Ruiby'\r\n```\r\n\r\n\r\nUsage with Event Machine: preload event-machine before Ruiby :\r\n\r\n```ruby \r\nrequire 'em-proxy'\r\nrequire 'Ruiby'\r\n```\r\n\r\nWarning : EM.run is done when starting mainloop, after creation of window(s).\r\nSo, if you need initialization of event-machine callback, do it in component(), in a after(0):\r\n\r\n```ruby \r\nRuiby.app do\r\n  ....\r\n  after(0) { EventMachine::start_server().. { ... } }\r\nend\r\n```\r\n\r\nSee samples/spygui.rb, for exemple of gui with EM.\r\n\r\n\r\nThreading\r\n=========\r\nRuiby does not have confidence in gtk multi threading, so all Ruiby commands must be done in\r\nmain thread context. A Ruiby delegate is provided in Kernel module for support multi-threading\r\n\r\nA Queue is polled by main-window thread :\r\n* main window poll Queue , messagers are proc to be instance_eval() in the main window context\r\n* everywere, a thread can invoke ```invoke_gui {ruiby code}```. this send to the main queue the proc,\r\n which will be evaluated asynchroniously \r\n\r\ninstance_eval is avoided in ruiby. He is used only for thread invoker : gui_invoke().\r\n\r\n```ruby\r\nrequire_relative '../lib/Ruiby'\r\nclass App < Ruiby_gtk\r\n    def initialize\r\n        super(\"Testing Ruiby for Threading\",150,0)\r\n\t\tthreader(10)\r\n\t\tThread.new { A.new.run }\r\n    end\r\n\tdef component()        \r\n\t  stack do\r\n\t\tsloti(label(\"Hello, this is Thread test !\"))\r\n\t\tstack { @lab=stacki { } }\r\n\t  end\r\n\tend # endcomponent\r\n\t\r\nend\r\nclass A\r\n\tdef run\r\n \t\tloop do\r\n\t\t \tsleep(1) # thread...\r\n\t\t\tthere=self \r\n\t\t\tgui_invoke { append_to(@lab) { sloti( \r\n\t\t\t\t\tlabel( there.aaa )  # ! instance_eval on main window\r\n\t\t\t)  } }\r\n\t\tend\r\n\tend \r\n\tdef aaa() Time.now.to_s  end\r\nend\r\n\r\nRuiby.start { App.new }\r\n\r\n```\r\n\r\nObserved Object/Variable\r\n========================\r\n\r\nDynamic variable\r\n----------------\r\nOften, a widget (an entry, a label, a slider...) show the value of a ruby variable.\r\neach time a code mofify this variable, it must modify the widget, and vice-versa...\r\nThis is very tyring :)\r\n\r\nWith data binding, this notifications are done by the framework\r\n\r\nSo ```DynVar``` can be  used for representing a value variable which is dynamics, ie. \r\nwhich must notify widgets which show the variable state.\r\n\r\nSo we can do :\r\n```ruby\r\n  foo=DynVar.new(0)\r\n  entry(foo)\r\n  islider(foo)\r\n  ....\r\n  foo.value=43  \r\n  ....\r\n```\r\n\r\nThat works ! the entry and the slider will be updated.\r\n\r\nA move on slider will update foo.value and the entry.\r\nIdem for a key in the entry : slider and foo.value will be updated.\r\n\r\nif you want to be notified for your own traitment, you can observ a DynVar :\r\n```ruby\r\n  foo.observ { |v| @socket.puts(v.to_s) rescue nil }\r\n```\r\n\r\nHere, a modification of foo variable will be send on the network...\r\n\r\nWarning !! the block will always be executed in the main thread context (mainloop gtk context).\r\nSo DynVar is a ressource internal to Ruiby framework.\r\n\r\nWidget which accept DynVar are : entry, ientry, islider, label, check_button, \r\n\r\n```must be extend to button, togglebutton, combo, radio_button ... list, grid,...```\r\n\r\n\r\nDynamic Object\r\n--------------\r\n\r\nOften, this kind of Dyn variables are members of a 'record', which should be organised by an\r\nRuby Object (a Struct...)\r\n\r\nSo ```DynObject``` create a class, which is organised by a hash  :\r\n* packet of variable name \r\n* put initial value for each\r\n* each variable will be a DynVar\r\n\r\n```ruby \r\n  FooClass=make_DynClass(\"v1\" => 1 , \"v2\" => 2, \"s1\" => 'Hello...')\r\n  foo=FooClass.new( \"s1\" => Time.now.to_s ) # default value of s1 variable is replaced \r\n  ...\r\n  label(\" foo: \") ; entry(foo.s1)\r\n  islider(foo.v1)\r\n  islider(foo.v2)\r\n  ....\r\n  button(\"4x33\") { Thread.new { foo.s1.value=\"s4e33\" ; foo.v2.value=33 ; foo.v1.value=4} }\r\n  ....\r\n```\r\n\r\nDynamic Stock Object\r\n--------------------\r\nDynObject can be persisted to filesystem : use ```make_StockDynObject```, and\r\ninstantiate with an object persistant ID\r\n\r\n```ruby \r\n  FooClass=make_StockDynClass(\"v1\"=> 1 , \"v2\" => 2, \"s1\" => 'Hello...')\r\n  foo1=FooClass.new( \"foo1\" , \"s1\" => Time.now.to_s )\r\n  foo2=FooClass.new( \"foo2\" , \"s1\" => (Time.now+10).to_s )\r\n  ....\r\n  button(\"Exit\") { ruiby_exit} # on exit, foo1 and foo2 will been saved to {tmpdir}/<$0>.storage  \r\n  ....\r\n```\r\n\r\n```make_StockDynObject``` do both : Class creation **and** class instanciation.\r\n\r\n```ruby \r\n  foo=make_StockDynObject(\"v1\"=> 1 , \"v2\" => 2, \"s1\" => 'Hello...')\r\n  ....\r\n  button(foo.s1) { foo.s1.value= prompt(\"new S1 value ?\")}\r\n  button(\"Exit\") { ruiby_exit} # on exit, foo1 and foo2 will been saved to {tmpdir}/<$0>.storage  \r\n  ....\r\n```\r\n\r\n\r\nLicense\r\n=======\r\nLGPL, CC BY-SA\r\n\r\nExemples\r\n========\r\nsee samples in \"./samples\" directory (run all.rb)\r\ncd sampSee at end of Doc reference : [Ex.](https://rawgithub.com/glurp/Ruiby/master/doc.html#code) ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}