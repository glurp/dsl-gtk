#####################################################################################
#          W I N  M O N I T O R / ruby-Ruiby-gtk  tools for watching home servers
#####################################################################################
if RUBY_PLATFORM != "i386-mingw32"
 puts "Oups!, #{$0} is For windows only !"
 exit(0)
end
require_relative '../lib/ruiby' 
require 'open-uri' 
require 'win32ole' # for wmi : process list
require 'tmpdir'

######################################################################
#  configuration : to be updated !!
######################################################################

##__ZONE__###################################################################################

ENV.delete("http_proxy")

$config=[
 ["Shared"     		,"dir"   ,"T:/"],
 ["Web Sources"		,"geturl","http://localhost"],
 ["@"				,"geturl","http://74.125.230.194:80"],
]

##__ZONE__###################################################################################
def show_config() Editor.new(self,File.read(__FILE__).split("##__ZONE__###")[1],600) end
#-----------------  Surveillances  actions --------------------------------
# do_<ACTIONNAME>() >> raise Exception if NOK ; ACTIONNAME is in $config[*][1]

def do_geturl(param) 	open(param).close end
def do_dir(param) 		raise "not found" if ! File.directory?(param) end
def do_tcpping(param)
	  ip,port=param.split(/:/)
	  raise("ping #{ip}:#{port}") unless tping(ip,port.to_i,0.3)
end

def tping(host,  service="echo", timeout=5)
   s=nil
   service=service.to_s unless String === service
   begin
		timeout(timeout) {	s = TCPSocket.new(host, service) }
	return(true)
   rescue Exception => e
	return false
   ensure
	  (s.close if s ) rescue nil
   end
end



######################################################################
### Icon set : Generated by ruiby : 'generate_source_icons'
######################################################################
$icons={}

$icons['fond']=<<EEND
iVBORw0KGgoAAAANSUhEUgAAABYAAAARCAYAAADZsVyDAAAABGdBTUEAALGP
C/xhBQAAAAlwSFlzAAAOvwAADr8BOAVTJAAAABp0RVh0U29mdHdhcmUAUGFp
bnQuTkVUIHYzLjUuMTAw9HKhAAAAVUlEQVQ4T7XMwQkAIRAEwYl/URRFFEVT
neOC6Ed9SxFhgoj0P7k4pWSCcs4mqJRigmqtJqi1ZoJ67yZojGECF885TdBa
ywTtvU3QOccE3XtN0HvPhA9cH/lAq8AX7AAAAABJRU5ErkJggg==
EEND

$icons['face_smile_big']=<<EEND
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
0/PN438AWlx9gkj5xeQAAAAASUVORK5CYII=
EEND
def get_icon_filename(name)
  raise("icon '#{name}' unknown in #{$icons.keys}") unless $icons[name]
  fname=File.join(Dir.tmpdir,name+".png")
  puts "#{name} ==> #{fname} / #{$icons[name].size}" if $DEBUG
  File.open(fname,"wb") { |f| f.write($icons[name].unpack('m')[0]) } 
  fname
end
######################################################################

$periode=$DEBUG ? 5 :60

Thread.abort_on_exception=true
$errorDetected=true



######################################################################
#  process list, with   memories occupation, kill, detail...
######################################################################
def make_list_process()
	wmi = WIN32OLE.connect("winmgmts://")
	lp = wmi.ExecQuery("select * from win32_process")
	l=[]
	lp.each { |pr| l << [pr.Caption.strip,pr.ProcessId,pr.PeakPageFileUsage.to_s,pr.CommandLine.strip[0..90].ljust(90)] rescue nil}
	wmi.ole_free
	text=l.sort { |a,b| b[2].to_i <=> a[2].to_i}[0..160]
	max=[0]*30
	text.each { |line| line.map! {|c| (c=~/[0-9]/) ? c.to_s.gsub(/(\d)(?=(\d\d\d)+(?!\d))/, "\\1 "): c}}
	text.map { |line| line.each_with_index.map {|c,i| c.to_s.rjust(max[i])}}
end
def detail_process(pid)
	wmi = WIN32OLE.connect("winmgmts://")
	lp = wmi.ExecQuery("select * from win32_process where ProcessId=#{pid}")
	descr=[] ; lp.each { |p| descr=p ; break}
	data={}
	descr.Properties_.each { |x| 
		n=x.name 
		data[n]=descr.send(n) 
	} 
	wmi.ole_free
	data
end
$nameproc=%w{name PID size cmd}
def show_processus()
	$ppp=PopupTable.new("Process",800,500,$nameproc,make_list_process(),{
		"Kill        " => proc {|line| system("taskkill","/f","/pid",line[1]) ; refresh_process() },
		"Refresh     " => proc {|line| refresh_process() },
		"Detail      " => proc {|line|
			pid=line[1].to_i
			data=detail_process(pid)
			pp=PopupForm.new("Process #{line[0]}",0,0,data,{
				"kill"=> proc { system("taskkill","/f","/pid",line[1]) if ask("Realy Kill #{line[0]} ?") },
				"Refresh" => proc {|w,data| w.set_data(detail_process(pid)) }
			},{:edit=>true,:scroll=>[800,450]})
	}})
end
def refresh_process() 
 $ppp.update(make_list_process())
end


######################################################################
#  netstat , with process descriptor
######################################################################
$filtre=/L/
class NetStat < Ruiby_gtk
	def initialize()
		super("Netstat",400,700)
	end
	def component()
		@periode=2000
		stack do
			@grid=grid(%w{flag source destination proc pid proc-size},500,100)
			@grid.set_data(net_to_table($filtre))	
			buttoni("Refresh") { @grid.set_data(net_to_table($filtre)) }
			flowi do
				button("Filter") { prompt("Filter ?",$fi) { |value| $fi=value;$filtre=Regexp.new($fi) } }
				button("Periode") { 
					prompt("periode (ms) ?",@periode.to_s) { |value| 
						delete(@ann)
						@periode=[1000,20000,value.to_i].sort[1]
						@ann=anim(@periode) { 
							Thread.new {
								d=net_to_table($filtre) ; gui_invoke { @grid.set_data(d) } 
							} unless @active.active? 
						} 
					}
				}
				@active=check_button("Freese",false) 
			end
		end		
		@ann=anim(@periode) { 
			Thread.new {
				d=net_to_table($filtre) 
				gui_invoke_in_window(self) { @grid.set_data(d) }  if @ann && !@active.active?
			} 
		} 
		on_destroy  { ann,@ann=@ann,nil; delete(ann)  }
	end
end

def net_to_table(filtre)
	hpid={}
	%x{tasklist}.split(/\r?\n/).each { |line| 
	  ll=line.chomp.split(/\s+/) 
	  next if ll.length<5
	  prog,pid,x,y,*l=ll
	  hpid[pid]= [prog,l.join(" ")]
	}
	ret=[]
	%x{netstat -ano}.split(/^/).each { |line|
	 proto,src,dst,flag,pid=line.chomp.strip.split(/\s+/)  
	 prog,s = hpid[pid]||["?","?"]
	 ret << [flag,src,dst,prog,pid.to_i,s] if [flag,src,dst,prog,pid,s].inspect =~  filtre	 
	}
	ret.sort { |a,b| a[4]<=>b[4]}
end




#--------------------------- Surveillance Engine ---------------------------
# actions runs in paralleles, result is sorted by config order
# a queue is used for collect actions results (array are not thread-safe)

$last_action = Time.now 

def do_surveillance(expand)
	no0=0
	lth=[]
	queue=Queue.new
	$config.each do |text0,comm0,param0, action0|
	  lth<<Thread.new(text0,comm0,param0,no0,action0) do |text,comm,param,no,action|
		begin
			send("do_#{comm}",param)
			queue.push([no,false,text])
		rescue				
			if action && (Time.now > $last_action + 60) # only one action by minutes
			    $last_action = Time.now 
				Thread.new(action) { |action| instance_eval  &action rescue alert($!.to_s) }
			end
			queue.push([no,true,text])
		end
	  end
	  no0+=1
	end
	lth.map(&:join)
	r=[]
	while queue.size>0 && (m=queue.pop)
		r << m 
	end
	return ( r.sort { |a,b| a[0]<=>b[0] } )
end


class Application < Ruiby_gtk
	def update(expand) 
		Thread.new {
		  now=Time.now.to_f
		  result=do_surveillance(expand) rescue p($!) ;
		  gui_invoke { do_raffraichissement(result,expand,now) }
		}
	end
	def do_raffraichissement(r,expand,now)
		nbError=0
		clear_append_to(@st) do 
			r.each do |mess|
				no,err=*mess
				flow {
					sloti(label("  "+$config[no][0] + (err ? " : NOK" : " : ok"),{:font => "Arial"}))
					nbError+=1 if err
				} if err or expand
			end
			flow {
				sloti(label("  "+Time.now.to_s.split(/ /)[1] + "  ("+((Time.now.to_f-now)*1000).round.to_s+" ms)"))
			}
		end
		# mettre en avant-plan la fenetre si detection d'apparition d'erreur(s)
		if nbError>0
			if ! $errorDetected
				#$statusIcon.blinking=true
				#$statusIcon.visible=true
				#$statusIcon.file=UNHAPPY_ICON
				show
				iconify
				deiconify
				$errorDetected=true
			end
		else
			if  $errorDetected
				$errorDetected=false
			else
				(hide;return) unless expand
			end
		end
		h=(17+2)*(1+(expand ? $config.size : nbError))
		default_height=h
		move(2420,960-h)
	end   		
end

unless  defined?($statusIcon)
	$statusIcon=nil
	$win=nil 
	$p={}
	$h=(17+2)*($config.size+1)
	class Application
	  def initialize()
		  super("Monitoring",100,0)
		  default_height=0
		  height=0
		  
		  threader(20)
		  move(2420,960-$h)
		  chrome(false)
		  $app=self
		  $win=self
		  after(500) { update(true) }       # do one test with display all status
		  anim($periode*1000) { update(false) }

		  systray(nil,830) do
			syst_icon  get_icon_filename('face_smile_big')
		    syst_add_button "Reload"				do |state| load(__FILE__) rescue log $! ; end
			syst_add_button "Configuration"			do |state| show_config end
			syst_add_button "Execute Test"			do |state|  move(2420,960-$h);show; update(true) end
			config_systray_button(self)				if defined?(config_systray_button)
			syst_add_button  "Process"  			do |state| show_processus() end 
			syst_add_button  "Netstat"  			do |state| NetStat.new end 
			syst_quit_button true
			#17.times { |i| syst_add_button  "#{i}"  			do |state|  end } 
		  end
	  end
	  def selection(wi) update(true)  end
	  def component
	    def_style(x=<<-EEND)
		  pixmap_path "#{Dir.tmpdir}"
		  style "dark" {  bg[NORMAL] = { 1.0, 0.1, 0.1 }  }	
		  style "box"  {  bg_pixmap[NORMAL] = 'fond.png'  }	
		  style "mstyle" { 
		    font_name   = "Arial"
		    fg[NORMAL] = { 0.9, 0.9, 0.9 } 
			bg_pixmap[NORMAL] = 'fond.png'
		  }	
		  class  "*Button*"   style "dark"
		  class  "*Box*"      style "box"
		  class  "*Label*"    style "box"
	    EEND
		clickable(:selection) { @st= stack { @a=slot(label("...")) } }
	  end
	end
	Ruiby.start { Application.new }
end # unless defined?
